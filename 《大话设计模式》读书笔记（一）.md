# 《大话设计模式》读书笔记（一）

### 一、心得

​	今天的读书笔记是记录《大话设计模式》中附录部分从**（A2-A5）**的内容，为了能让自己更好的去阅读Laravel的源码，从书堆中捡起了大话设计模式这本书，看的时候发现自己把这些面向对象中最基本的概念都还给老师了:joy:，看的时候觉得自己还是学到了一些东西，最深的感悟就是一个知识点不同的阶段去看收获完全不同。

​	在看书的过程中也会去搜索下相关的知识点，学习一些书本上可能漏掉的相关知识点，话不多说，上干货。

### 二、具体概念以及代码

#### A2：类与实例

​	先问问大家，对象是什么？类是什么？

​	平时大家可能经常声明一个类和对象，但是对于他的具体定义有很多人可能说不上来。一切事物皆为对象，对象就是你所有能看到的、听到的、触摸到的以及闻到的等…。准确地说，**对象是一个自包含的实体，用一组可识别的特征和行为来标识**。面向对象编程，英文叫**Object-Oriented Programming**，其实就是针对对象的编程。接下来我们将以一个运动会的例子来给大家讲解下以上的概念。

​	首先实现一个功能，输出“让猫叫”，这个非常简单。

​	`printf("喵");`

​	嗯，这个功能是实现了，如果我们需要小猫多“喵”几次怎么办？写个函数不就行了么。

```c++
void catShout() {
    printf("喵");
}
```

​	很好，现在的问题是，万一别的地方也要用怎怎么办？

​	可以声明public方法呀，嗯，是可以。那函数放在哪里呢？你觉得放在这个地方好么？这就好比，居委会的电视机放在你家，而别人家都没有，于是街坊邻居都要来你家看电视，你觉得这样好么？电视机不应该放在居委会，大家要看电视就去居委会么？

​	所以说，这“猫叫”的函数应该放在一个更合适的地方，这就是”类“。**类就是拥有相同的属性和功能的对象的集合**，我们来看代码。

```c++
class Cat {
    public string Shout() {
        return "喵";
    }
}
```

​	那怎么使用这个类呢？我们只要实例化这个类就可以了，那怎么实例化这个类呢？**实例**就是一个真实的对象，比如我们都是人，而你我都是“人”类的实例了，**实例化就是创建对象的过程，使用new关键字来创建。**下面就是实例化的代码。实例化之后的cat就拥有了Cat所有的成员和方法。

​	`Cat cat = new Cat();`



#### A3：构造方法

​	下面我们希望出生的小猫应该有个自己的名字，比如叫猫咪，当小猫叫的时候最好能说：“我的名字叫猫咪，喵”，此时就需要考虑构造方法。

​	构造方法？这是做什么的呢？

​	“**构造方法又叫构造函数，其实就是对类的初始化。构造方法与类同名，无返回值，也不需要void，在new的时候调用**”。

​	在`Cat act = new Cat();`的时候new后面的Cat()其实就是构造方法，不对呀，我们没写过这个构造方法呀。嗯，实际情况就是**所有的类都有构造方法，如果你不声明，则系统就会默认生成空的构造方法，若你有定义的构造方法，则默认的构造方法会失效**，下面我们就来实现一个拥有名字小猫“喵”的功能。

```c++
class Cat {
    private string name = "";
    public Cat(string name) {
        this.name = name;
    }
    public string Shout() {
        return "我的名字叫" + name + " 喵";
    }
}
```

​	想要调用该方法

```c++
Cat cat = new Cat("猫咪");
cat->Shout();
```

​	这样我们就实现了“拥有名字的小猫叫喵”的功能了，简单吧。:happy:

#### A4：重载

​	如果我们还没有给小猫取好名字怎么办呢？难道这个实例就不能创建了么？嗯，有些父母在孩子刚生下来的时候确实没有给小孩子取好名字，如果现在直接`Cat cat = new Cat();`就会报错，原因就是必须给小猫取名字，如果真的要还没想好取什么名字的话可以用**重载**来解决这个问题。

​	“**方法的重载提供了创建同名的多个方法的能力，但是这些方法需要使用不同的参数**”，并不是只有构造函数才可以重载，普通的方法也是可以重载的。

```c++
class Cat {
    private string name = "";
    public Cat(string name) {
        this.name = name;
    }
    public Cat() {
        this.name = "无名";
    }
    public string Shout() {
        return "我的名字叫" + name + " 喵";
    }
}
```

​	这样的话`Cat cat = new Cat();`就不会报错了。**方法重载时，两个方法名必须完全相同，但参数类型或者个数必须要有所不同**。那函数重载的好处是什么呢？我想应该是方法的重载可以在不改变原来方法的基础上，新增功能。方法的重载确实提高了函数的可扩展性，如果我们还需要区分猫的姓和名还可以再重载一个`public Cat(string firstName, string lastName);`



#### A5：属性与修饰符

​	**属性是一个方法或一对方法，但在调用它的代码来看，它是一个字段，也就是说属性适合于以字段的方法使用调用的场合。**字段是存储类满足其设计所需要的数据，比如说我们上面提到的`private string name="";`，name就是一个字段，那么修饰符又是指什么呢？

​	修饰符表示的是对类成员权限的声明，例如我们上面提到的public、private以及protected都是修饰符。public表示它所修饰的类成员可以允许其他任何类来访问，俗称公有类。而private表示只允许同一类中的成员访问，其他类包括它的子类都无法访问，俗称私有类。如果类中的成员没有加修饰符，则被认为是private的。protected后面我们会讲到。

```c++
class Cat {
    private int ShoutNum = "";
    public void setShoutNum(int num) {
        this.ShoutNum = num;
    }
    public int getShoutNum() {
        return this.ShoutNum;
    }
}
```

​	一般我们会把类的成员变量设置为private，想要操作类的成员变量就可以自己写一些get和set方法就好了，那我们为什么要这样做呢？这就好比建房子，我们都不希望房子是全透明的，那样你在家里做的所有事情都会被被人看到，这样就毫无隐私可言。通常我们的房子是有门有窗的，门窗就好比oublic方法，房子里的东西都是private的。这样房子就比较好控制，只要控制好门窗就比较安全了。